using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq.Expressions;
using System.Net.WebSockets;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Xml;
// TODO LIST
/*  
 * 
 *  select the value after the colons?
 *  dictionary for items, so there are no repeats
 *  
 */


namespace Plugins_to_cpp_h
{
    internal class Program{
        const string version = "Zedd_0.4.1";

        static XmlNode root_node;
        static StreamWriter file;
        static int indentation_count = 0;

        static void Main(string[] args){
            string orign_plugins_path = "C:\\Users\\Joe bingle\\Downloads\\H5Plugins\\";
            string output_converted_path = "C:\\Users\\Joe bingle\\Downloads\\H5Plugins_CPP\\";
            if (!Directory.Exists(orign_plugins_path)){
                Console.WriteLine("Failed to find specified input path, retry with the correct path");
                return;
            }
            if (!Directory.Exists(output_converted_path)){
                Console.WriteLine("Failed to find specified output path, retry with the correct path");
                return;
            }
            goto Start;
        Error:
            Console.WriteLine("conversion failed");
        Start:
            Console.WriteLine("Hello, World!\nSelect the plugin to convert\nExample: \"vehi\"\n");
            string plugin_name = Console.ReadLine();
            string chosen_path = orign_plugins_path + plugin_name + ".xml";
            if (!File.Exists(chosen_path)) goto Error;

            Console.WriteLine("beginning conversion from: " + chosen_path);

            XmlDocument xdoc = new();
            xdoc.Load(chosen_path);
            root_node = xdoc.SelectSingleNode("plugin");

            string output_path = output_converted_path + plugin_name + ".h";
            file = new StreamWriter(output_path);
            // file prelude header

            file.WriteLine("/*");
            file.WriteLine("; CONTENT AUTOGENERATED BY CODENAME ATRIOX: PLUGIN CONVERTOR (lord zedd edition)");
            file.WriteLine("; CONVERTOR VERSION: " + version);
            file.WriteLine("; SOURCE TIMESTAMP: " + "[EXAMPLE]");
            file.WriteLine("; SOURCE GAME VERSION: " + "[EXAMPLE]");
            file.WriteLine("; SOURCE PLUGIN: " + plugin_name);
            file.WriteLine("; GENERATED TIMESTAMP: " + DateTime.Today.Date.ToString("dd/MM/yyyy") + " -> " + DateTime.Now.ToString("h:mm:ss tt"));
            file.WriteLine("*/");
            file.WriteLine("");
            file.WriteLine("#include \"commons.h\"");
            file.WriteLine("#pragma pack(push, 1)");
            file.WriteLine("");




            file.WriteLine("struct " + filter_string(plugin_name) + "{");
            indentation_count++;
            process_struct(root_node);
            indentation_count--;
            file.WriteLine("};");


            file.WriteLine("#pragma pack(pop)");
            file.Close();
            file.Dispose();

            // then output the header file
            //file = new StreamWriter(other_output_path);
            //file.WriteLine("#pragma once");
            //file.WriteLine("#include \"commons.h\"");

            //for (int i = 0; i < structs_queue.Count; i++)   file.WriteLine("struct " + filter_string(structs_queue[i].Attributes?["Name"]?.Value) + ";");
            //for (int i = 0; i < flags_queue.Count; i++)     file.WriteLine("struct " + filter_string(flags_queue[i].Attributes?["StructName1"]?.Value) + ";");
            //for (int i = 0; i < enums_queue.Count; i++)     file.WriteLine("enum " + filter_string(enums_queue[i].Attributes?["StructName1"]?.Value) + ";");

            //file.Close();
            //file.Dispose();

            Console.WriteLine("finished conversion to: " + output_path + "\n");
            goto Start;
        }
        static Dictionary<string, XmlNode> found_structures = new(); //for each of these we need to check if it does actually match
        // if it doesn't match then we probably are going to have an interesting problem
        static List<XmlNode> structs_queue = new();
        static List<List<string>> struct_lines = new();
        static List<XmlNode> flags_queue = new();
        static List<XmlNode> enums_queue = new();


        static void process_struct(XmlNode current_struct){

            foreach (XmlNode param in current_struct.ChildNodes)
                preprocess_n_param(param);
            foreach (XmlNode param in current_struct.ChildNodes)
                process_n_param(param);
        }
        static byte get_index_from_typestring(string type){
            for (byte i = 0; i < group_lengths_dict.Length; i++)
                if (group_lengths_dict[i].Key == type)
                    return i;
            throw new Exception("type not found");
            return 255;
        }
        // hmm, what do we do for generating a unique preprocess name??
        // maybe put a '__' before the name
        static string indent(){
            return new string(' ', indentation_count * 3);
        }
        static string generate_struct_name(string text){
            return "__" + text;
        }

        static void preprocess_n_param(XmlNode param){
            byte group_id = get_index_from_typestring(param.Name);
            string group_name = group_names[group_id].cpp;
            string param_name = filter_string(param.Attributes?["name"]?.Value);
            switch (group_id){
                // enum types
                case 10:
                case 11:
                case 12:{
                        string class_type = ""; // we could use refer to the actual class types here, that would be more efficient
                        if      (group_id == 10) class_type = "uint8_t";
                        else if (group_id == 11) class_type = "uint16_t";
                        else if (group_id == 12) class_type = "uint32_t";
                        file.WriteLine(indent() + "enum " + generate_struct_name(param_name) + " : " + class_type + " {");
                        indentation_count++;

                        for (int i = 0; i < param.ChildNodes.Count; i++){
                            XmlNode current = param.ChildNodes[i];
                            file.WriteLine(indent() + filter_string(current.Attributes?["Name"]?.Value) + " = " + i + ",");
                        }

                        indentation_count--;
                        file.WriteLine(indent() + "};");
                    }break;
                // flags types
                case 13:
                case 14:
                case 15:{
                        file.WriteLine(indent() + "struct " + generate_struct_name(param_name) + "{");
                        indentation_count++;

                        int bit_count = -1;
                        if      (group_id == 13) { bit_count = 32; file.WriteLine("   uint32_t content;"); }
                        else if (group_id == 14) { bit_count = 16; file.WriteLine("   uint16_t content;"); }
                        else if (group_id == 15) { bit_count = 8;  file.WriteLine("   uint8_t content;" ); }

                        for (int i = 0; i < param.ChildNodes.Count; i++){
                            XmlNode current = param.ChildNodes[i];

                            char[] chars = new string('0', bit_count).ToCharArray();
                            chars[chars.Length - 1 - i] = '1';
                            string bit_mask = new string(chars);
                            // this may need fixing tbh // i still agree with that statement
                            file.WriteLine(indent() + "bool " + filter_string(current.Attributes?["Name"]?.Value) + "() { return ( content  & 0b" + bit_mask + "); }");
                        }
                        indentation_count--;
                        file.WriteLine(indent() + "};");
                    }break;
                // struct types
                case 56:
                case 57:
                case 67:
                case 64:{ 
                        file.WriteLine(indent() + "struct " + generate_struct_name(param_name) + "{");
                        indentation_count++;
                        process_struct(param);
                        indentation_count--;
                        file.WriteLine(indent() + "};");
                   }break;
            }
        }

        static void process_n_param(XmlNode param){
            byte group_id = get_index_from_typestring(param.Name);
            string group_name = group_names[group_id].cpp;
            string param_name = filter_string(param.Attributes?["name"]?.Value);

            switch (group_id){
                // string types
                case 0:
                    file.WriteLine(indent() + group_name + " " + param_name + "[32];");
                    break;
                case 1:
                    file.WriteLine(indent() + group_name + " " + param_name + "[256];");
                    break;
                case 9:
                    file.WriteLine(indent() + group_name + " " + param_name + "[4];");
                    break;
                // enum types
                case 10:
                case 11:
                case 12:{
                        string target_node = generate_struct_name(param_name);
                        file.WriteLine(indent() + target_node + " " + param_name + ";");
                    }break;
                // flags types
                case 13:
                case 14:
                case 15:{
                        string target_node = generate_struct_name(param_name);
                        file.WriteLine(indent() + target_node + " " + param_name + ";");
                    }break;
                // spacer types
                case 52:
                case 53:
                        int length = Convert.ToInt32(param.Attributes?["length"]?.Value);
                        file.WriteLine(indent() + group_name + " " + param_name + "["+ length + "];");
                    break;
                // not to be processed types
                case 54:
                case 55:
                case 59:
                    break; // aka exiting the switch entirely
                // struct types
                case 56:{ 
                        string target_node = generate_struct_name(param_name);
                        file.WriteLine(indent() + target_node + " " + param_name + ";");
                   }break;
                case 57:{
                        throw new Exception("arrays unsupported, syntax unknown");
                        //string next_struct_name = filter_string(next_struct.Attributes?["Name"]?.Value);
                        //string next_struct_count = next_struct.Attributes?["Count"]?.Value;
                        //file.WriteLine("   " + next_struct_name + " " + param_name + "["+ next_struct_count + "];");
                   }break;
                // template types
                case 67:
                case 64:{ 
                        string target_node = generate_struct_name(param_name);
                        file.WriteLine(indent() + group_name + "<" + target_node + "> " + param_name + ";");
                   }break;
                // unmapped types
                case 68:
                    file.WriteLine(indent() + group_name + " " + param_name + ";" + " // WARNING: THIS TYPE WILL CAUSE ISSUES //");
                    break;
                // unspecified types
                default:
                    file.WriteLine(indent() + group_name + " " + param_name + ";");
                    break;
            }
        }
        


        // new pattern to do only the ones we want:: [^a-zA-Z0-9 -]
        static string _reg_pattern = "[^a-zA-Z0-9_]";
        static Regex _reg_regEx = new Regex(_reg_pattern);
        static string filter_string(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "BLANK";
            string output = Regex.Replace(_reg_regEx.Replace(input, "_"), @"\s+", " ");
            if (0x2A < output[0] && output[0] < 0x3A ) return "_" + output;
            return output;
        }

        public struct string_pair{
            public string xml;
            public string cpp;
            public string_pair(string _xml, string _cpp){
                xml = _xml;
                cpp = _cpp;
        }}

        // ##SOR = "special output required"
        // ##SCT = "special case type"
        // ##NIT = "not included type"

        public static string_pair[] group_names = new string_pair[]
        {
            new ("string32", "char" ),          // ##SCT
            new ("string256", "char" ),         // ##SCT
            new ("stringID", "uint32_t" ),
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("sbyte", "int8_t" ),
            new ("short", "int16_t" ),
            new ("int", "int32_t" ),
            new ("long", "int64_t" ),
            new ("angle", "float" ),
            new ("group", "char" ),             // ##SCT
            new ("enum8", "" ),         // ##SOR
            new ("enum16", "" ),        // ##SOR
            new ("enum32", "" ),        // ##SOR
            new ("flags32", "" ),   // ##SOR
            new ("flags16", "" ),   // ##SOR
            new ("flags8", "" ),     // ##SOR
            new ("point2D", "_s_point2d" ),       
            new ("rectangle2D", "WWWWWWWWWWW" ),  
            new ("rgb", "_s_rgb" ),               
            new ("argb", "_s_argb" ),             
            new ("float", "float" ),
            new ("fraction", "float" ),
            new ("float2D", "_s_doublefloat" ),   
            new ("float3D", "_s_triplefloat" ),   
            new ("vector2D", "_s_doublefloat" ),  
            new ("vector3D", "_s_triplefloat" ),  
            new ("quarternion", "_s_quadfloat" ), 
            new ("euler2D", "_s_doublefloat" ),   
            new ("euler3D", "_s_triplefloat" ),   
            new ("plane2D", "_s_triplefloat" ),   
            new ("plane3D", "_s_quadfloat" ),     
            new ("rgb_float", "_s_rgbfloat" ),    
            new ("argb_float", "_s_argbfloat" ),  
            new ("hsv", "WWWWWWWWWWW" ),
            new ("ahsv", "WWWWWWWWWWW" ),
            new ("short_r", "_s_shortrange" ),     
            new ("angle_r", "_s_floatrange" ),     
            new ("float_r", "_s_floatrange" ),     
            new ("fraction_r", "_s_floatrange" ),  
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("b_flags32", "WWWWWWWWWWW" ),
            new ("b_flags16", "WWWWWWWWWWW" ),
            new ("b_flags8", "WWWWWWWWWWW" ),
            new ("block8", "int8_t" ),
            new ("cblock8", "int8_t" ),
            new ("block16", "int16_t" ),
            new ("cblock16", "int16_t" ),
            new ("block32", "int32_t" ),
            new ("cblock32", "int32_t" ),
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("padding", "uint8_t" ),           // ##SCT
            new ("skip", "uint8_t" ),              // ##SCT
            new ("comment", "" ),       // ##NIT
            new ("c_comment", "" ),     // ##NIT
            new ("struct", "" ),                // ##SCT
            new ("array", "" ),                 // ##SCT 
            new ("UNKNOWN", "WWWWWWWWWWW" ),
            new ("struct_end", "" ),    // ##NIT
            new ("byte", "uint8_t" ),
            new ("ushort", "uint16_t" ),
            new ("uint", "uint32_t" ),
            new ("ulong", "uint64_t" ),
            new ("tagblock", "_s_tagblock" ),              // ##SCT
            new ("tagref", "_s_tagref" ),                // ##SCT
            new ("data", "_s_data" ),                  // ##SCT
            new ("resource", "_s_resource" ),              // ##SCT
            new ("file_reference", "uint32_t" ),
            new ("UNKNOWN", "WWWWWWWWWWW" ),
        };
        // SPECIAL STRUCTS THAT BELONG IN THE COMMON.H


        public static KeyValuePair<string, long>[] group_lengths_dict = {
            new ( "_field_string", 32 ),  // 
			new ( "_field_long_string", 256 ), // 
			new ( "_field_string_id", 4 ),   // 
			new ( "", 4 ),   // 
			new ( "_field_char_integer", 1 ),   // 
			new ( "_field_short_integer", 2 ),   // 
			new ( "_field_long_integer", 4 ),   // 
			new ( "_field_int64_integer", 8 ),   // 
			new ( "_field_angle", 4 ),   // 
			new ( "_field_tag", 4 ),   // 
			new ( "_field_char_enum", 1 ),   // 
			new ( "_field_short_enum", 2 ),   // 
			new ( "_field_long_enum", 4 ),   // 
			new ( "_field_long_flags", 4 ),   // 
			new ( "_field_word_flags", 2 ),   // 
			new ( "_field_byte_flags", 1 ),   // 
			new ( "_field_point_2d", 4 ),  // 
			new ( "_field_rectangle_2d", 4 ),  // 
			new ( "_field_rgb_color", 4 ),  // 
			new ( "_field_argb_color ", 4 ),  // 
			new ( "_field_real", 4 ),  // 
			new ( "_field_real_fraction", 4 ),  // 
			new ( "_field_real_point_2d", 8 ),  // 
			new ( "_field_real_point_3d", 12 ), // 
			new ( "_field_real_vector_2d  ", 8 ),  // 
			new ( "_field_real_vector_3d", 12 ), // 
			new ( "_field_real_quaternion", 16 ), // 
			new ( "_field_real_euler_angles_2d", 8 ),  // 
			new ( "_field_real_euler_angles_3d", 12 ), // 
			new ( "_field_real_plane_2d", 12 ), // 
			new ( "_field_real_plane_3d", 16 ), // 
			new ( "_field_real_rgb_color", 12 ), // 
			new ( "_field_real_argb_color", 16 ), // 
			new ( "_field_real_hsv_colo", 4 ),  // 
			new ( "_field_real_ahsv_color", 4 ),  // 
			new ( "_field_short_bounds", 4 ),  // 
			new ( "_field_angle_bounds", 8 ),  // 
			new ( "_field_real_bounds", 8 ),  // 
			new ( "_field_real_fraction_bounds", 8 ),  // 
			new ( "", 4 ),  // 
			new ( "", 4 ),  // 
			new ( "_field_long_block_flags", 4 ),  // 
			new ( "_field_word_block_flags", 4 ),  // 
			new ( "_field_byte_block_flags", 4 ),  // 
			new ( "_field_char_block_index", 1 ),  // 
			new ( "_field_custom_char_block_index", 1 ),  // 
			new ( "_field_short_block_index", 2 ),  // 
			new ( "_field_custom_short_block_index", 2 ),  // 
			new ( "_field_long_block_index", 4 ),  // 
			new ( "_field_custom_long_block_index", 4 ),  // 
			new ( "", 4 ),  // 
			new ( "", 4 ),  // 
			new ( "_field_pad", 4 ),  // 
			new ( "_field_skip", 4 ),  // 
			new ( "_field_explanation", 0 ),  // 
			new ( "_field_custom", 0 ),  // 
			new ( "_field_struct", 0 ),  // 
			new ( "_field_array", 32 ), // 
			new ( "", 4 ),  // 
            new ( "", 0 ),  // 
			new ( "_field_byte_integer", 1 ),  // 
			new ( "_field_word_integer", 2 ),  // 
			new ( "_field_dword_integer", 4 ),  // 
			new ( "_field_qword_integer", 8 ),  // 
			new ( "_field_block_64", 20 ), // 
			new ( "_field_reference_64", 28 ), // unsure of name
			new ( "_field_data_64", 24 ), // 
			new ( "_field_pageable_resource_64", 16 ), // 

			new ( "", 4 ),
            new ( "", 4 ),
        };


    }











}